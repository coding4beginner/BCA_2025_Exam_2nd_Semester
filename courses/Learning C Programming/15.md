# Part 15: Advanced Data Structures in C

## Chapter 15.1: Trees in C

### 15.1.1: Introduction to Tree Data Structures

Trees are hierarchical data structures that are widely used in computer science and programming. Unlike linear data structures like arrays, linked lists, and queues, trees are non-linear and represent hierarchical relationships between elements. In this subchapter, we'll explore what tree data structures are, why they are important, and how they can be implemented in C.

Trees are essential because they allow us to represent hierarchical relationships efficiently, such as file systems, organization charts, or family trees. They provide efficient operations for insertion, deletion, and searching, making them perfect for applications requiring frequent data manipulation and retrieval. Understanding trees will significantly enhance your data structure toolkit and enable you to solve complex problems more efficiently.

A tree consists of nodes connected by edges, with one node designated as the root. Each node can have zero or more child nodes, and except for the root, every node has exactly one parent. Nodes without children are called leaf nodes. The height of a tree is the length of the longest path from the root to a leaf, while the depth of a node is its distance from the root.

Trees come in various forms, including binary trees (where each node has at most two children), binary search trees (where nodes are arranged in a specific order), AVL trees (self-balancing binary search trees), and B-trees (used in databases and file systems). Each type of tree has specific properties and use cases that make it suitable for different applications.

In C, trees are typically implemented using structures and pointers, with each node containing data and pointers to its children. Though C doesn't have built-in tree data structures, we can create custom implementations that suit our specific requirements. Throughout this subchapter, we'll explore the fundamentals of trees and gradually build our understanding of these powerful data structures.

#### Code Sample 1: Basic Tree Node Structure

```c
// Basic structure for a tree node
struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
};

// Function to create a new tree node
struct TreeNode* createNode(int value) {
    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    if (newNode == NULL) {
        printf("Memory allocation failed!\n");
        exit(1);
    }
    newNode->data = value;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}
```

#### Code Sample 2: Creating a Simple Binary Tree

```c
// Function to create a simple binary tree
struct TreeNode* createSampleTree() {
    struct TreeNode* root = createNode(1);
    root->left = createNode(2);
    root->right = createNode(3);
    root->left->left = createNode(4);
    root->left->right = createNode(5);
    return root;
}
```

#### Code Sample 3: Traverse a Binary Tree (In-order)

```c
// Function to traverse a binary tree in-order
void inOrderTraversal(struct TreeNode* root) {
    if (root != NULL) {
        inOrderTraversal(root->left);
        printf("%d ", root->data);
        inOrderTraversal(root->right);
    }
}
```

#### Code Sample 4: Traverse a Binary Tree (Pre-order)

```c
// Function to traverse a binary tree pre-order
void preOrderTraversal(struct TreeNode* root) {
    if (root != NULL) {
        printf("%d ", root->data);
        preOrderTraversal(root->left);
        preOrderTraversal(root->right);
    }
}
```

#### Code Sample 5: Traverse a Binary Tree (Post-order)

```c
// Function to traverse a binary tree post-order
void postOrderTraversal(struct TreeNode* root) {
    if (root != NULL) {
        postOrderTraversal(root->left);
        postOrderTraversal(root->right);
        printf("%d ", root->data);
    }
}
```

#### Exercises:

1. Implement a function to count the number of nodes in a binary tree.
2. Write a function to find the height of a binary tree.
3. Create a function to check if a binary tree is balanced.
4. Implement a function to find the deepest node in a binary tree.
5. Write a program to convert a binary tree to its mirror image.

### 15.1.2: Binary Search Trees (BST)

Binary Search Trees (BSTs) are a special type of binary tree with an ordered structure that facilitates efficient searching, insertion, and deletion operations. In this subchapter, we'll explore what BSTs are, their properties, and how to implement common operations on them using C.

Binary Search Trees follow a specific ordering property: for any node, all elements in its left subtree are less than the node's value, and all elements in its right subtree are greater than the node's value. This property enables binary search operations, making BSTs valuable for applications that require frequent lookups, insertions, and deletions.

We need BSTs because they combine the logarithmic time complexity advantages of binary search with the dynamic nature of linked structures. In an ideally balanced BST, operations like search, insert, and delete have an average time complexity of O(log n), which is significantly more efficient than linear data structures for large datasets. However, if the tree becomes unbalanced (such as when elements are inserted in sorted order), performance can degrade to O(n).

In C, we implement BSTs using structures and pointers, similar to binary trees. Each node contains a value and pointers to its left and right children. The BST structure itself typically starts with a pointer to the root node. Operations on BSTs often utilize recursive functions due to the hierarchical nature of tree traversal.

When working with BSTs, it's essential to maintain the BST property during insertions and deletions. Special care must be taken when deleting nodes, especially those with two children, to ensure the tree remains a valid BST after the operation. Understanding these operations will enable you to effectively utilize BSTs in your programs.

In the following examples, we'll implement and explore common BST operations including creation, search, insertion, deletion, and traversal. Each operation maintains the BST property, ensuring the data structure remains efficient for future operations.

#### Code Sample 1: BST Node Structure and Initialization

```c
// BST node structure
struct BSTNode {
    int data;
    struct BSTNode* left;
    struct BSTNode* right;
};

// Function to create a new BST node
struct BSTNode* createBSTNode(int value) {
    struct BSTNode* newNode = (struct BSTNode*)malloc(sizeof(struct BSTNode));
    if (newNode == NULL) {
        printf("Memory allocation failed!\n");
        exit(1);
    }
    newNode->data = value;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}
```

#### Code Sample 2: BST Insertion

```c
// Function to insert a value into a BST
struct BSTNode* insert(struct BSTNode* root, int value) {
    // If the tree is empty, create a new node
    if (root == NULL) {
        return createBSTNode(value);
    }
    
    // Otherwise, recur down the tree
    if (value < root->data) {
        root->left = insert(root->left, value);
    } else if (value > root->data) {
        root->right = insert(root->right, value);
    }
    
    // Return the unchanged node pointer
    return root;
}
```

#### Code Sample 3: BST Search

```c
// Function to search for a value in a BST
struct BSTNode* search(struct BSTNode* root, int value) {
    // Base case: root is NULL or the value is at the root
    if (root == NULL || root->data == value) {
        return root;
    }
    
    // Value is greater than root's data
    if (value > root->data) {
        return search(root->right, value);
    }
    
    // Value is less than root's data
    return search(root->left, value);
}
```

#### Code Sample 4: Finding Minimum and Maximum in BST

```c
// Function to find the node with minimum value in a BST
struct BSTNode* findMin(struct BSTNode* root) {
    if (root == NULL) {
        return NULL;
    }
    
    struct BSTNode* current = root;
    while (current->left != NULL) {
        current = current->left;
    }
    return current;
}

// Function to find the node with maximum value in a BST
struct BSTNode* findMax(struct BSTNode* root) {
    if (root == NULL) {
        return NULL;
    }
    
    struct BSTNode* current = root;
    while (current->right != NULL) {
        current = current->right;
    }
    return current;
}
```

#### Code Sample 5: BST Deletion

```c
// Function to delete a node with a given value from BST
struct BSTNode* deleteNode(struct BSTNode* root, int value) {
    // Base case
    if (root == NULL) {
        return root;
    }
    
    // Recursive calls for ancestors of the node to be deleted
    if (value < root->data) {
        root->left = deleteNode(root->left, value);
    } else if (value > root->data) {
        root->right = deleteNode(root->right, value);
    } else {
        // Node with only one child or no child
        if (root->left == NULL) {
            struct BSTNode* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct BSTNode* temp = root->left;
            free(root);
            return temp;
        }
        
        // Node with two children: Get the inorder successor
        struct BSTNode* temp = findMin(root->right);
        
        // Copy the inorder successor's content to this node
        root->data = temp->data;
        
        // Delete the inorder successor
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}
```

#### Exercises:

1. Implement a function to check if a binary tree is a valid BST.
2. Write a function to find the kth smallest element in a BST.
3. Create a function to print all elements in a BST that fall within a given range.
4. Implement a function to convert a sorted array to a balanced BST.
5. Write a program to find the lowest common ancestor of two nodes in a BST.

### 15.1.3: AVL Trees

AVL trees are self-balancing binary search trees named after their inventors Adelson-Velsky and Landis. In this subchapter, we'll explore what AVL trees are, why they're important, and how to implement them in C, focusing on the balancing mechanisms that make them efficient.

AVL trees are a special type of binary search tree that automatically maintains balance after insertions and deletions. In an AVL tree, the heights of the two child subtrees of any node differ by at most one. This balance factor ensures that operations like search, insert, and delete maintain logarithmic time complexity, even in worst-case scenarios.

We need AVL trees because regular binary search trees can degenerate into linked lists when elements are inserted in sorted order, resulting in O(n) operation times. AVL trees solve this problem by performing rotations to maintain balance, ensuring operations remain O(log n) regardless of the insertion order. This guaranteed efficiency makes AVL trees valuable for applications requiring predictable performance.

In C, AVL trees are implemented as structures with additional height information for each node. Each node contains a value, pointers to left and right children, and a height value. The difference between left and right subtree heights (the balance factor) determines when and how to perform rotations to restore balance after modifications.

AVL trees use four types of rotations to maintain balance: left rotation, right rotation, left-right rotation (double rotation), and right-left rotation (double rotation). These rotations are triggered when a node's balance factor becomes greater than 1 or less than -1 after an insertion or deletion operation.

Understanding AVL trees provides insights into balancing mechanisms that are fundamental to many advanced data structures. Though more complex than basic BSTs, the performance guarantees of AVL trees make them worth the additional implementation complexity for performance-critical applications.

#### Code Sample 1: AVL Tree Node Structure

```c
// AVL tree node structure
struct AVLNode {
    int data;
    struct AVLNode* left;
    struct AVLNode* right;
    int height; // Height of the subtree rooted with this node
};

// Function to create a new AVL node
struct AVLNode* createAVLNode(int value) {
    struct AVLNode* newNode = (struct AVLNode*)malloc(sizeof(struct AVLNode));
    if (newNode == NULL) {
        printf("Memory allocation failed!\n");
        exit(1);
    }
    newNode->data = value;
    newNode->left = NULL;
    newNode->right = NULL;
    newNode->height = 1; // New node is initially added at leaf level
    return newNode;
}
```

#### Code Sample 2: Height and Balance Factor Functions

```c
// Function to get the height of a node
int height(struct AVLNode* node) {
    if (node == NULL)
        return 0;
    return node->height;
}

// Function to get maximum of two integers
int max(int a, int b) {
    return (a > b) ? a : b;
}

// Function to get balance factor of a node
int getBalance(struct AVLNode* node) {
    if (node == NULL)
        return 0;
    return height(node->left) - height(node->right);
}
```

#### Code Sample 3: Rotation Functions

```c
// Right rotate subtree rooted with y
struct AVLNode* rightRotate(struct AVLNode* y) {
    struct AVLNode* x = y->left;
    struct AVLNode* T2 = x->right;
    
    // Perform rotation
    x->right = y;
    y->left = T2;
    
    // Update heights
    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;
    
    // Return new root
    return x;
}

// Left rotate subtree rooted with x
struct AVLNode* leftRotate(struct AVLNode* x) {
    struct AVLNode* y = x->right;
    struct AVLNode* T2 = y->left;
    
    // Perform rotation
    y->left = x;
    x->right = T2;
    
    // Update heights
    x->height = max(height(x->left), height(x->right)) + 1;
    y->height = max(height(y->left), height(y->right)) + 1;
    
    // Return new root
    return y;
}
```

#### Code Sample 4: AVL Tree Insertion

```c
// Insert a node into AVL tree
struct AVLNode* insert(struct AVLNode* node, int value) {
    // 1. Perform standard BST insertion
    if (node == NULL)
        return createAVLNode(value);
    
    if (value < node->data)
        node->left = insert(node->left, value);
    else if (value > node->data)
        node->right = insert(node->right, value);
    else // Equal values not allowed in BST
        return node;
    
    // 2. Update height of this ancestor node
    node->height = 1 + max(height(node->left), height(node->right));
    
    // 3. Get the balance factor
    int balance = getBalance(node);
    
    // 4. If unbalanced, handle the 4 cases
    
    // Left Left Case
    if (balance > 1 && value < node->left->data)
        return rightRotate(node);
    
    // Right Right Case
    if (balance < -1 && value > node->right->data)
        return leftRotate(node);
    
    // Left Right Case
    if (balance > 1 && value > node->left->data) {
        node->left = leftRotate(node->left);
        return rightRotate(node);
    }
    

    // Right Left Case
    if (balance < -1 && value < node->right->data) {
        node->right = rightRotate(node->right);
        return leftRotate(node);
    }
    
    // Return the unchanged node pointer
    return node;
}
```

#### Code Sample 5: AVL Tree Deletion

```c
// Function to delete a node from AVL tree
struct AVLNode* deleteNode(struct AVLNode* root, int value) {
    // Standard BST delete
    if (root == NULL)
        return root;
    
    // If the key to be deleted is smaller than the root's key
    if (value < root->data)
        root->left = deleteNode(root->left, value);
    
    // If the key to be deleted is greater than the root's key
    else if (value > root->data)
        root->right = deleteNode(root->right, value);
    
    // If key is same as root's key, then this is the node to be deleted
    else {
        // Node with only one child or no child
        if ((root->left == NULL) || (root->right == NULL)) {
            struct AVLNode* temp = root->left ? root->left : root->right;
            
            // No child case
            if (temp == NULL) {
                temp = root;
                root = NULL;
            } else // One child case
                *root = *temp; // Copy the contents of the non-empty child
            
            free(temp);
        } else {
            // Node with two children: Get the inorder successor
            struct AVLNode* temp = findMinAVL(root->right);
            
            // Copy the inorder successor's data to this node
            root->data = temp->data;
            
            // Delete the inorder successor
            root->right = deleteNode(root->right, temp->data);
        }
    }
    
    // If the tree had only one node then return
    if (root == NULL)
        return root;
    
    // Update height of current node
    root->height = 1 + max(height(root->left), height(root->right));
    
    // Get balance factor
    int balance = getBalance(root);
    
    // If unbalanced, handle the 4 cases
    
    // Left Left Case
    if (balance > 1 && getBalance(root->left) >= 0)
        return rightRotate(root);
    
    // Left Right Case
    if (balance > 1 && getBalance(root->left) < 0) {
        root->left = leftRotate(root->left);
        return rightRotate(root);
    }
    
    // Right Right Case
    if (balance < -1 && getBalance(root->right) <= 0)
        return leftRotate(root);
    
    // Right Left Case
    if (balance < -1 && getBalance(root->right) > 0) {
        root->right = rightRotate(root->right);
        return leftRotate(root);
    }
    
    return root;
}

// Function to find the node with minimum value in AVL tree
struct AVLNode* findMinAVL(struct AVLNode* node) {
    struct AVLNode* current = node;
    while (current->left != NULL)
        current = current->left;
    return current;
}
```

#### Exercises:

1. Implement a function to verify if a tree satisfies all AVL tree properties.
2. Write a function to convert a Binary Search Tree to an AVL tree.
3. Create a function to find the height-balanced factor of each node in an AVL tree.
4. Implement a function to perform level-order traversal of an AVL tree.
5. Write a program to merge two AVL trees into a single balanced AVL tree.

### 15.1.4: Tree Traversal Algorithms

Tree traversal algorithms provide systematic ways to visit all nodes in a tree data structure. In this subchapter, we'll explore different traversal methods, their implementations in C, and their applications in solving tree-related problems.

Tree traversal algorithms are essential for processing tree structures systematically. They provide ordered ways to visit every node in a tree exactly once, which is fundamental for operations like searching, printing, or transforming tree data. Understanding traversal algorithms is critical because they form the basis of many tree-related operations and algorithms.

We need tree traversal methods because they allow us to access tree elements in specific orders that are useful for different tasks. For example, in-order traversal of a binary search tree yields nodes in sorted order, while level-order traversal processes nodes based on their distance from the root, which is useful for breadth-first search applications.

The four primary traversal methods are:
1. In-order traversal (left-root-right): Visits the left subtree, then the root, then the right subtree.
2. Pre-order traversal (root-left-right): Visits the root first, then the left subtree, then the right subtree.
3. Post-order traversal (left-right-root): Visits the left subtree, then the right subtree, then the root.
4. Level-order traversal: Visits nodes level by level, from left to right.

In C, tree traversals are typically implemented using recursive functions for depth-first approaches (in-order, pre-order, post-order) and queues for breadth-first approaches (level-order). Each method has its advantages and is suited for specific applications, such as expression evaluation, tree copying, or hierarchical data processing.

Choosing the right traversal method depends on the problem you're solving. For example, post-order traversal is useful for deleting trees (as it processes children before parents), while level-order traversal is valuable for finding the shortest path in unweighted trees.

#### Code Sample 1: In-order Traversal Implementation

```c
// Function to perform in-order traversal of a binary tree
void inOrderTraversal(struct TreeNode* root) {
    if (root != NULL) {
        // First recur on left child
        inOrderTraversal(root->left);
        
        // Then visit the root
        printf("%d ", root->data);
        
        // Finally recur on right child
        inOrderTraversal(root->right);
    }
}
```

#### Code Sample 2: Pre-order Traversal Implementation

```c
// Function to perform pre-order traversal of a binary tree
void preOrderTraversal(struct TreeNode* root) {
    if (root != NULL) {
        // First visit the root
        printf("%d ", root->data);
        
        // Then recur on left child
        preOrderTraversal(root->left);
        
        // Finally recur on right child
        preOrderTraversal(root->right);
    }
}
```

#### Code Sample 3: Post-order Traversal Implementation

```c
// Function to perform post-order traversal of a binary tree
void postOrderTraversal(struct TreeNode* root) {
    if (root != NULL) {
        // First recur on left child
        postOrderTraversal(root->left);
        
        // Then recur on right child
        postOrderTraversal(root->right);
        
        // Finally visit the root
        printf("%d ", root->data);
    }
}
```

#### Code Sample 4: Level-order Traversal Using Queue

```c
// Function to perform level-order traversal of a binary tree
void levelOrderTraversal(struct TreeNode* root) {
    if (root == NULL) return;
    
    // Create a queue for level order traversal
    struct Queue* queue = createQueue();
    
    // Enqueue root
    enqueue(queue, root);
    
    // Loop until queue is empty
    while (!isEmpty(queue)) {
        // Print front of queue and remove it from queue
        struct TreeNode* node = dequeue(queue);
        printf("%d ", node->data);
        
        // Enqueue left child
        if (node->left != NULL)
            enqueue(queue, node->left);
        
        // Enqueue right child
        if (node->right != NULL)
            enqueue(queue, node->right);
    }
    
    // Free the queue
    free(queue);
}

// Basic queue implementation for level order traversal
struct QueueNode {
    struct TreeNode* data;
    struct QueueNode* next;
};

struct Queue {
    struct QueueNode *front, *rear;
};

struct Queue* createQueue() {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    queue->front = queue->rear = NULL;
    return queue;
}

int isEmpty(struct Queue* queue) {
    return (queue->front == NULL);
}

void enqueue(struct Queue* queue, struct TreeNode* item) {
    struct QueueNode* newNode = (struct QueueNode*)malloc(sizeof(struct QueueNode));
    newNode->data = item;
    newNode->next = NULL;
    
    if (queue->rear == NULL) {
        queue->front = queue->rear = newNode;
        return;
    }
    
    queue->rear->next = newNode;
    queue->rear = newNode;
}

struct TreeNode* dequeue(struct Queue* queue) {
    if (isEmpty(queue))
        return NULL;
    
    struct QueueNode* temp = queue->front;
    struct TreeNode* item = temp->data;
    
    queue->front = queue->front->next;
    
    if (queue->front == NULL)
        queue->rear = NULL;
    
    free(temp);
    return item;
}
```

#### Code Sample 5: Iterative In-order Traversal Using Stack

```c
// Iterative function for in-order traversal
void iterativeInOrder(struct TreeNode* root) {
    if (root == NULL) return;
    
    // Create an empty stack
    struct Stack* stack = createStack(100);
    struct TreeNode* current = root;
    
    // Traverse the tree
    while (current != NULL || !isStackEmpty(stack)) {
        // Reach the leftmost node of the current node
        while (current != NULL) {
            // Place pointer to a tree node on the stack
            // before traversing the node's left subtree
            push(stack, current);
            current = current->left;
        }
        
        // Current must be NULL at this point
        current = pop(stack);
        
        // Visit the node
        printf("%d ", current->data);
        
        // We have visited the node and its left subtree.
        // Now, it's right subtree's turn
        current = current->right;
    }
    
    // Free the stack
    free(stack);
}

// Basic stack implementation for iterative traversals
struct Stack {
    int size;
    int top;
    struct TreeNode** array;
};

struct Stack* createStack(int size) {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack->size = size;
    stack->top = -1;
    stack->array = (struct TreeNode**)malloc(stack->size * sizeof(struct TreeNode*));
    return stack;
}

int isStackEmpty(struct Stack* stack) {
    return stack->top == -1;
}

int isStackFull(struct Stack* stack) {
    return stack->top == stack->size - 1;
}

void push(struct Stack* stack, struct TreeNode* item) {
    if (isStackFull(stack))
        return;
    stack->array[++stack->top] = item;
}

struct TreeNode* pop(struct Stack* stack) {
    if (isStackEmpty(stack))
        return NULL;
    return stack->array[stack->top--];
}
```

#### Exercises:

1. Implement a function to perform spiral level-order traversal of a binary tree (zigzag traversal).
2. Write a function to perform boundary traversal of a binary tree (traversing only the boundary nodes).
3. Create a function to perform diagonal traversal of a binary tree.
4. Implement a function to find the vertical sum of a binary tree using level-order traversal.
5. Write a program to serialize and deserialize a binary tree using pre-order traversal.

#### End of Chapter Questions:

1. **Question**: What is the difference between a binary tree and a binary search tree?
   **Answer**: A binary tree is a tree data structure where each node has at most two children. A binary search tree (BST) is a special type of binary tree that follows an ordering property: for any node, all elements in its left subtree are less than the node's value, and all elements in its right subtree are greater than the node's value.

2. **Question**: What is the balance factor in an AVL tree, and why is it important?
   **Answer**: The balance factor of a node in an AVL tree is the height of its left subtree minus the height of its right subtree. It's important because it determines whether the tree is balanced or not. In an AVL tree, the balance factor of every node must be -1, 0, or 1 to maintain O(log n) time complexity for operations.

3. **Question**: If you perform an in-order traversal on a binary search tree, what special property will the output have?
   **Answer**: An in-order traversal of a binary search tree will output the elements in ascending sorted order.

4. **Question**: What are the four types of rotations used in AVL trees to maintain balance?
   **Answer**: The four types of rotations are: Left Rotation (LL), Right Rotation (RR), Left-Right Rotation (LR, which is a double rotation: left rotation followed by right rotation), and Right-Left Rotation (RL, which is a double rotation: right rotation followed by left rotation).

5. **Question**: Which tree traversal method would you use if you needed to delete an entire tree, ensuring that child nodes are deleted before their parents?
   **Answer**: Post-order traversal should be used for deleting an entire tree because it ensures that all children of a node are processed before the node itself. This prevents attempts to access memory that has already been freed, as would happen if parent nodes were deleted before their children.

## Chapter 15.2: Graphs in C

### 15.2.1: Introduction to Graph Data Structures

Graphs are versatile data structures that model a set of objects (vertices) and the connections between them (edges). In this subchapter, we'll explore what graphs are, their various types, and how they can be represented and manipulated in C.

Graphs are fundamental data structures consisting of vertices (also called nodes) and edges that connect pairs of vertices. Unlike trees, which are hierarchical, graphs can represent more complex relationships where connections can exist between any pair of elements. This flexibility makes graphs ideal for modeling real-world problems such as social networks, road maps, computer networks, and scheduling dependencies.

Understanding graphs is essential because they provide a mathematical framework for solving numerous computational problems. From finding the shortest path between two points to determining if a network can be traversed without retracing steps, graph algorithms are powerful tools in a programmer's arsenal. Mastering graph concepts will significantly enhance your problem-solving capabilities.

In C, graphs can be represented using several methods, including adjacency matrices, adjacency lists, and edge lists. Each representation has advantages and disadvantages in terms of memory usage, operation efficiency, and implementation complexity. Choosing the right representation depends on the specific problem you're solving and the operations you'll perform most frequently.

Graphs come in various forms:
- Directed vs. undirected: In directed graphs, edges have direction (from one vertex to another), while in undirected graphs, edges have no direction.
- Weighted vs. unweighted: Weighted graphs assign values (weights) to edges, representing distances, costs, or capacities.
- Cyclic vs. acyclic: Cyclic graphs contain at least one cycle (a path that starts and ends at the same vertex), while acyclic graphs have no cycles.
- Connected vs. disconnected: In connected graphs, there's a path between every pair of vertices, while disconnected graphs consist of multiple connected components.

Throughout this subchapter, we'll explore these concepts and learn how to implement and manipulate graph structures in C. We'll focus on practical implementations and algorithms that solve common graph-related problems.

#### Code Sample 1: Graph Representation Using Adjacency Matrix

```c
// Adjacency Matrix representation of a graph
#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTICES 100

// A structure to represent a graph
typedef struct Graph {
    int V; // Number of vertices
    int E; // Number of edges
    int** adjMatrix; // Adjacency matrix
} Graph;

// Function to create a graph with V vertices
Graph* createGraph(int V) {
    Graph* graph = (Graph*) malloc(sizeof(Graph));
    graph->V = V;
    graph->E = 0;
    
    // Allocate memory for
    // Allocate memory for adjacency matrix
    graph->adjMatrix = (int**) malloc(V * sizeof(int*));
    for (int i = 0; i < V; i++) {
        graph->adjMatrix[i] = (int*) malloc(V * sizeof(int));
        // Initialize all entries as 0 (no edge)
        for (int j = 0; j < V; j++) {
            graph->adjMatrix[i][j] = 0;
        }
    }
    
    return graph;
}

// Function to add an edge to an undirected graph
void addEdge(Graph* graph, int src, int dest) {
    // Add an edge from src to dest
    graph->adjMatrix[src][dest] = 1;
    
    // Since the graph is undirected, add an edge from dest to src as well
    graph->adjMatrix[dest][src] = 1;
    
    graph->E++;
}

// Function to print the adjacency matrix
void printGraph(Graph* graph) {
    printf("Adjacency Matrix:\n");
    for (int i = 0; i < graph->V; i++) {
        for (int j = 0; j < graph->V; j++) {
            printf("%d ", graph->adjMatrix[i][j]);
        }
        printf("\n");
    }
}

// Function to free the graph
void freeGraph(Graph* graph) {
    for (int i = 0; i < graph->V; i++) {
        free(graph->adjMatrix[i]);
    }
    free(graph->adjMatrix);
    free(graph);
}
```

#### Code Sample 2: Graph Representation Using Adjacency List

```c
// Adjacency List representation of a graph
#include <stdio.h>
#include <stdlib.h>

// A structure to represent an adjacency list node
typedef struct AdjListNode {
    int dest;
    struct AdjListNode* next;
} AdjListNode;

// A structure to represent an adjacency list
typedef struct AdjList {
    AdjListNode* head;
} AdjList;

// A structure to represent a graph
typedef struct Graph {
    int V;
    AdjList* array;
} Graph;

// Function to create a new adjacency list node
AdjListNode* newAdjListNode(int dest) {
    AdjListNode* newNode = (AdjListNode*) malloc(sizeof(AdjListNode));
    newNode->dest = dest;
    newNode->next = NULL;
    return newNode;
}

// Function to create a graph of V vertices
Graph* createGraph(int V) {
    Graph* graph = (Graph*) malloc(sizeof(Graph));
    graph->V = V;
    
    // Create an array of adjacency lists. Size of array will be V
    graph->array = (AdjList*) malloc(V * sizeof(AdjList));
    
    // Initialize each adjacency list as empty by making head as NULL
    for (int i = 0; i < V; i++) {
        graph->array[i].head = NULL;
    }
    
    return graph;
}

// Function to add an edge to an undirected graph
void addEdge(Graph* graph, int src, int dest) {
    // Add an edge from src to dest
    AdjListNode* newNode = newAdjListNode(dest);
    newNode->next = graph->array[src].head;
    graph->array[src].head = newNode;
    
    // Since the graph is undirected, add an edge from dest to src as well
    newNode = newAdjListNode(src);
    newNode->next = graph->array[dest].head;
    graph->array[dest].head = newNode;
}

// Function to print the adjacency list representation of graph
void printGraph(Graph* graph) {
    for (int v = 0; v < graph->V; ++v) {
        AdjListNode* pCrawl = graph->array[v].head;
        printf("\nAdjacency list of vertex %d\n head ", v);
        while (pCrawl) {
            printf("-> %d", pCrawl->dest);
            pCrawl = pCrawl->next;
        }
        printf("\n");
    }
}

// Function to free the graph
void freeGraph(Graph* graph) {
    // Free all adjacency lists
    for (int v = 0; v < graph->V; v++) {
        AdjListNode* pCrawl = graph->array[v].head;
        while (pCrawl) {
            AdjListNode* temp = pCrawl;
            pCrawl = pCrawl->next;
            free(temp);
        }
    }
    free(graph->array);
    free(graph);
}
```

#### Code Sample 3: Weighted Graph Implementation

```c
// Weighted Graph implementation using adjacency list
#include <stdio.h>
#include <stdlib.h>

// A structure to represent an adjacency list node
typedef struct AdjListNode {
    int dest;
    int weight;
    struct AdjListNode* next;
} AdjListNode;

// A structure to represent an adjacency list
typedef struct AdjList {
    AdjListNode* head;
} AdjList;

// A structure to represent a graph
typedef struct Graph {
    int V;
    AdjList* array;
} Graph;

// Function to create a new adjacency list node
AdjListNode* newAdjListNode(int dest, int weight) {
    AdjListNode* newNode = (AdjListNode*) malloc(sizeof(AdjListNode));
    newNode->dest = dest;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

// Function to create a graph of V vertices
Graph* createGraph(int V) {
    Graph* graph = (Graph*) malloc(sizeof(Graph));
    graph->V = V;
    
    // Create an array of adjacency lists. Size of array will be V
    graph->array = (AdjList*) malloc(V * sizeof(AdjList));
    
    // Initialize each adjacency list as empty by making head as NULL
    for (int i = 0; i < V; i++) {
        graph->array[i].head = NULL;
    }
    
    return graph;
}

// Function to add an edge to an undirected weighted graph
void addEdge(Graph* graph, int src, int dest, int weight) {
    // Add an edge from src to dest
    AdjListNode* newNode = newAdjListNode(dest, weight);
    newNode->next = graph->array[src].head;
    graph->array[src].head = newNode;
    
    // Since the graph is undirected, add an edge from dest to src as well
    newNode = newAdjListNode(src, weight);
    newNode->next = graph->array[dest].head;
    graph->array[dest].head = newNode;
}

// Function to print the adjacency list representation of graph
void printGraph(Graph* graph) {
    for (int v = 0; v < graph->V; ++v) {
        AdjListNode* pCrawl = graph->array[v].head;
        printf("\nAdjacency list of vertex %d\n head ", v);
        while (pCrawl) {
            printf("-> %d(w:%d) ", pCrawl->dest, pCrawl->weight);
            pCrawl = pCrawl->next;
        }
        printf("\n");
    }
}
```

#### Code Sample 4: Directed Graph Implementation

```c
// Directed Graph implementation using adjacency list
#include <stdio.h>
#include <stdlib.h>

// A structure to represent an adjacency list node
typedef struct AdjListNode {
    int dest;
    struct AdjListNode* next;
} AdjListNode;

// A structure to represent an adjacency list
typedef struct AdjList {
    AdjListNode* head;
} AdjList;

// A structure to represent a directed graph
typedef struct Graph {
    int V;
    AdjList* array;
} Graph;

// Function to create a new adjacency list node
AdjListNode* newAdjListNode(int dest) {
    AdjListNode* newNode = (AdjListNode*) malloc(sizeof(AdjListNode));
    newNode->dest = dest;
    newNode->next = NULL;
    return newNode;
}

// Function to create a graph of V vertices
Graph* createGraph(int V) {
    Graph* graph = (Graph*) malloc(sizeof(Graph));
    graph->V = V;
    
    // Create an array of adjacency lists. Size of array will be V
    graph->array = (AdjList*) malloc(V * sizeof(AdjList));
    
    // Initialize each adjacency list as empty by making head as NULL
    for (int i = 0; i < V; i++) {
        graph->array[i].head = NULL;
    }
    
    return graph;
}

// Function to add an edge to a directed graph
void addEdge(Graph* graph, int src, int dest) {
    // Add an edge from src to dest
    AdjListNode* newNode = newAdjListNode(dest);
    newNode->next = graph->array[src].head;
    graph->array[src].head = newNode;
    
    // Note: In a directed graph, we don't add an edge from dest to src
}

// Function to check if there is an edge from src to dest
int hasEdge(Graph* graph, int src, int dest) {
    // Check if there is an edge from src to dest
    AdjListNode* pCrawl = graph->array[src].head;
    while (pCrawl) {
        if (pCrawl->dest == dest)
            return 1;
        pCrawl = pCrawl->next;
    }
    return 0;
}

// Function to print the adjacency list representation of graph
void printGraph(Graph* graph) {
    for (int v = 0; v < graph->V; ++v) {
        AdjListNode* pCrawl = graph->array[v].head;
        printf("\nAdjacency list of vertex %d\n head ", v);
        while (pCrawl) {
            printf("-> %d", pCrawl->dest);
            pCrawl = pCrawl->next;
        }
        printf("\n");
    }
}
```

#### Code Sample 5: Edge List Representation of a Graph

```c
// Edge List representation of a graph
#include <stdio.h>
#include <stdlib.h>

// A structure to represent an edge
typedef struct Edge {
    int src, dest, weight;
} Edge;

// A structure to represent a graph
typedef struct Graph {
    int V, E;
    Edge* edge;
} Graph;

// Function to create a graph of V vertices and E edges
Graph* createGraph(int V, int E) {
    Graph* graph = (Graph*) malloc(sizeof(Graph));
    graph->V = V;
    graph->E = E;
    
    // Allocate memory for E edges
    graph->edge = (Edge*) malloc(E * sizeof(Edge));
    
    return graph;
}

// Function to add an edge to the graph
void addEdge(Graph* graph, int index, int src, int dest, int weight) {
    if (index >= graph->E) {
        printf("Edge index out of bounds\n");
        return;
    }
    
    graph->edge[index].src = src;
    graph->edge[index].dest = dest;
    graph->edge[index].weight = weight;
}

// Function to print the edge list
void printGraph(Graph* graph) {
    printf("Edge List Representation:\n");
    printf("Src\tDest\tWeight\n");
    for (int i = 0; i < graph->E; i++) {
        printf("%d\t%d\t%d\n", graph->edge[i].src, graph->edge[i].dest, graph->edge[i].weight);
    }
}

// Function to free the graph
void freeGraph(Graph* graph) {
    free(graph->edge);
    free(graph);
}
```

#### Exercises:

1. Implement a function to check if a graph is connected (there is a path between every pair of vertices).
2. Write a function to count the number of connected components in an undirected graph.
3. Create a function to check if a directed graph is a Directed Acyclic Graph (DAG).
4. Implement a function to convert between adjacency matrix and adjacency list representations.
5. Write a program to find the in-degree and out-degree of each vertex in a directed graph.

### 15.2.2: Graph Traversal Algorithms

Graph traversal algorithms provide systematic ways to visit all vertices in a graph. In this subchapter, we'll explore depth-first search (DFS) and breadth-first search (BFS), two fundamental traversal methods, and implement them in C.

Graph traversal algorithms are essential techniques for exploring the structure of a graph. They provide systematic methods to visit every vertex and edge in a graph exactly once, which is fundamental for solving many graph-related problems. Understanding these traversal methods is crucial because they form the foundation for more complex graph algorithms.

We need graph traversal algorithms because they allow us to systematically explore graphs to find paths, detect cycles, identify connected components, and solve many other graph-related problems. They're the first step in understanding the structure and properties of a graph, similar to how tree traversals help us understand tree structures.

The two primary graph traversal methods are:
1. Depth-First Search (DFS): Explores as far as possible along each branch before backtracking. DFS uses a stack (usually implemented using recursion) to keep track of vertices to be explored.
2. Breadth-First Search (BFS): Explores all the neighboring vertices at the present depth before moving to vertices at the next depth level. BFS uses a queue to keep track of vertices to be explored.

In C, these traversals are typically implemented using adjacency lists or matrices to represent the graph, along with appropriate data structures (stacks for DFS, queues for BFS) to manage the traversal. Additionally, we need to track visited vertices to avoid processing the same vertex multiple times, especially in graphs with cycles.

DFS and BFS have different properties that make them suitable for different applications. DFS is often simpler to implement (especially with recursion) and uses less memory for sparse graphs. BFS guarantees the shortest path in unweighted graphs and is better for finding the shortest path or closest vertices.

Let's implement both traversal algorithms and explore their applications in solving graph-related problems.

#### Code Sample 1: Depth-First Search (DFS) Implementation

```c
// DFS implementation using adjacency list
#include <stdio.h>
#include <stdlib.h>

// Graph structure from previous subchapter (using adjacency list)
typedef struct AdjListNode {
    int dest;
    struct AdjListNode* next;
} AdjListNode;

typedef struct AdjList {
    AdjListNode* head;
} AdjList;

typedef struct Graph {
    int V;
    AdjList* array;
} Graph;

// Function to create a new adjacency list node
AdjListNode* newAdjListNode(int dest) {
    AdjListNode* newNode = (AdjListNode*) malloc(sizeof(AdjListNode));
    newNode->dest = dest;
    newNode->next = NULL;
    return newNode;
}

// Function to create a graph of V vertices
Graph* createGraph(int V) {
    Graph* graph = (Graph*) malloc(sizeof(Graph));
    graph->V = V;
    
    // Create an array of adjacency lists
    graph->array = (AdjList*) malloc(V * sizeof(AdjList));
    
    // Initialize each adjacency list as empty
    for (int i = 0; i < V; i++) {
        graph->array[i].head = NULL;
    }
    
    return graph;
}

// Function to add an edge to an undirected graph
void addEdge(Graph* graph, int src, int dest) {
    // Add an edge from src to dest
    AdjListNode* newNode = newAdjListNode(dest);
    newNode->next = graph->array[src].head;
    graph->array[src].head = newNode;
    
    // Add an edge from dest to src (un
    // Add an edge from dest to src (undirected graph)
    newNode = newAdjListNode(src);
    newNode->next = graph->array[dest].head;
    graph->array[dest].head = newNode;
}

// DFS utility function
void DFSUtil(Graph* graph, int vertex, int visited[]) {
    // Mark the current node as visited and print it
    visited[vertex] = 1;
    printf("%d ", vertex);
    
    // Recur for all the vertices adjacent to this vertex
    AdjListNode* pCrawl = graph->array[vertex].head;
    while (pCrawl) {
        if (!visited[pCrawl->dest]) {
            DFSUtil(graph, pCrawl->dest, visited);
        }
        pCrawl = pCrawl->next;
    }
}

// DFS traversal of the vertices reachable from vertex v
void DFS(Graph* graph, int startVertex) {
    // Mark all the vertices as not visited
    int* visited = (int*) malloc(graph->V * sizeof(int));
    for (int i = 0; i < graph->V; i++) {
        visited[i] = 0;
    }
    
    // Call the recursive helper function to print DFS traversal
    printf("DFS traversal starting from vertex %d: ", startVertex);
    DFSUtil(graph, startVertex, visited);
    printf("\n");
    
    free(visited);
}
```

#### Code Sample 2: Breadth-First Search (BFS) Implementation

```c
// BFS implementation using adjacency list
#include <stdio.h>
#include <stdlib.h>

// Graph structure (same as before)

// Queue implementation for BFS
typedef struct QueueNode {
    int data;
    struct QueueNode* next;
} QueueNode;

typedef struct Queue {
    QueueNode *front, *rear;
} Queue;

// Function to create a new queue
Queue* createQueue() {
    Queue* queue = (Queue*) malloc(sizeof(Queue));
    queue->front = queue->rear = NULL;
    return queue;
}

// Function to check if queue is empty
int isEmpty(Queue* queue) {
    return queue->front == NULL;
}

// Function to add an item to the queue
void enqueue(Queue* queue, int item) {
    QueueNode* newNode = (QueueNode*) malloc(sizeof(QueueNode));
    newNode->data = item;
    newNode->next = NULL;
    
    if (queue->rear == NULL) {
        queue->front = queue->rear = newNode;
        return;
    }
    
    queue->rear->next = newNode;
    queue->rear = newNode;
}

// Function to remove an item from the queue
int dequeue(Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty\n");
        return -1;
    }
    
    QueueNode* temp = queue->front;
    int item = temp->data;
    
    queue->front = queue->front->next;
    
    if (queue->front == NULL) {
        queue->rear = NULL;
    }
    
    free(temp);
    return item;
}

// Function to free the queue
void freeQueue(Queue* queue) {
    QueueNode* current = queue->front;
    QueueNode* next;
    
    while (current != NULL) {
        next = current->next;
        free(current);
        current = next;
    }
    
    free(queue);
}

// BFS traversal of the vertices reachable from vertex v
void BFS(Graph* graph, int startVertex) {
    // Mark all the vertices as not visited
    int* visited = (int*) malloc(graph->V * sizeof(int));
    for (int i = 0; i < graph->V; i++) {
        visited[i] = 0;
    }
    
    // Create a queue for BFS
    Queue* queue = createQueue();
    
    // Mark the current node as visited and enqueue it
    visited[startVertex] = 1;
    enqueue(queue, startVertex);
    
    printf("BFS traversal starting from vertex %d: ", startVertex);
    
    // BFS loop
    while (!isEmpty(queue)) {
        // Dequeue a vertex from queue and print it
        int currentVertex = dequeue(queue);
        printf("%d ", currentVertex);
        
        // Get all adjacent vertices of the dequeued vertex
        // If an adjacent vertex has not been visited, then mark it
        // visited and enqueue it
        AdjListNode* pCrawl = graph->array[currentVertex].head;
        while (pCrawl) {
            if (!visited[pCrawl->dest]) {
                visited[pCrawl->dest] = 1;
                enqueue(queue, pCrawl->dest);
            }
            pCrawl = pCrawl->next;
        }
    }
    
    printf("\n");
    
    // Free allocated memory
    free(visited);
    freeQueue(queue);
}
```

#### Code Sample 3: Finding Connected Components Using DFS

```c
// Function to find all connected components in an undirected graph
void findConnectedComponents(Graph* graph) {
    // Mark all the vertices as not visited
    int* visited = (int*) malloc(graph->V * sizeof(int));
    for (int i = 0; i < graph->V; i++) {
        visited[i] = 0;
    }
    
    int componentCount = 0;
    
    // Visit all vertices one by one
    for (int v = 0; v < graph->V; v++) {
        if (!visited[v]) {
            // Print all reachable vertices from v
            printf("Connected Component %d: ", ++componentCount);
            DFSUtil(graph, v, visited);
            printf("\n");
        }
    }
    
    printf("Total number of connected components: %d\n", componentCount);
    
    free(visited);
}
```

#### Code Sample 4: Detecting Cycles in an Undirected Graph Using DFS

```c
// Utility function to detect cycle in an undirected graph
int isCyclicUtil(Graph* graph, int v, int visited[], int parent) {
    // Mark the current node as visited
    visited[v] = 1;
    
    // Recur for all the vertices adjacent to this vertex
    AdjListNode* pCrawl = graph->array[v].head;
    while (pCrawl) {
        // If an adjacent is not visited, then recur for that adjacent
        if (!visited[pCrawl->dest]) {
            if (isCyclicUtil(graph, pCrawl->dest, visited, v))
                return 1;
        }
        // If an adjacent is visited and not parent of current vertex,
        // then there is a cycle
        else if (pCrawl->dest != parent)
            return 1;
        
        pCrawl = pCrawl->next;
    }
    return 0;
}

// Function to detect cycle in an undirected graph
int isCyclic(Graph* graph) {
    // Mark all the vertices as not visited
    int* visited = (int*) malloc(graph->V * sizeof(int));
    for (int i = 0; i < graph->V; i++) {
        visited[i] = 0;
    }
    
    // The call to isCyclicUtil serves as a DFS tree
    // For every vertex, check if there's a cycle
    for (int u = 0; u < graph->V; u++) {
        if (!visited[u]) {
            if (isCyclicUtil(graph, u, visited, -1))
                return 1;
        }
    }
    
    free(visited);
    return 0;
}
```

#### Code Sample 5: Finding Shortest Paths Using BFS

```c
// Function to find shortest paths from a given source vertex
void shortestPaths(Graph* graph, int source) {
    // Mark all the vertices as not visited
    int* visited = (int*) malloc(graph->V * sizeof(int));
    
    // Create an array to store distances
    int* distance = (int*) malloc(graph->V * sizeof(int));
    
    // Create an array to store predecessors (for path reconstruction)
    int* predecessor = (int*) malloc(graph->V * sizeof(int));
    
    // Initialize all distances as INFINITE and visited as false
    for (int i = 0; i < graph->V; i++) {
        visited[i] = 0;
        distance[i] = INT_MAX;
        predecessor[i] = -1;
    }
    
    // Distance of source vertex from itself is always 0
    distance[source] = 0;
    
    // Create a queue for BFS
    Queue* queue = createQueue();
    
    // Mark the source node as visited and enqueue it
    visited[source] = 1;
    enqueue(queue, source);
    
    // BFS loop
    while (!isEmpty(queue)) {
        // Dequeue a vertex from queue
        int u = dequeue(queue);
        
        // Get all adjacent vertices of the dequeued vertex
        AdjListNode* pCrawl = graph->array[u].head;
        while (pCrawl) {
            int v = pCrawl->dest;
            
            // If this adjacent vertex has not been visited,
            // then mark it visited and enqueue it
            if (!visited[v]) {
                visited[v] = 1;
                distance[v] = distance[u] + 1;
                predecessor[v] = u;
                enqueue(queue, v);
            }
            
            pCrawl = pCrawl->next;
        }
    }
    
    // Print the shortest distances
    printf("Shortest distances from vertex %d:\n", source);
    for (int i = 0; i < graph->V; i++) {
        if (distance[i] != INT_MAX) {
            printf("To vertex %d: %d\n", i, distance[i]);
        } else {
            printf("To vertex %d: Not reachable\n", i);
        }
    }
    
    // Free allocated memory
    free(visited);
    free(distance);
    free(predecessor);
    freeQueue(queue);
}
```

#### Exercises:

1. Implement a function to find all paths between two vertices in a graph using DFS.
2. Write a function to detect cycles in a directed graph using DFS.
3. Create a function to perform a topological sort of a directed acyclic graph (DAG) using DFS.
4. Implement a function to find the shortest path between two vertices in a weighted graph using BFS (assume all edges have equal weight).
5. Write a program to determine if a graph is bipartite using BFS.

